{"version":3,"sources":["../src/datasource.js"],"names":["_","DynatraceDatasource","instanceSettings","$q","backendSrv","templateSrv","type","name","q","id","jsonData","token","url","headers","Authorization","options","datasourceRequest","doRequest","then","status","message","title","catch","targets","filter","target","hide","fromTs","range","from","_d","getTime","toTs","to","requests","Object","keys","forEach","t","opts","method","data","aggregationType","aggregation","endTimestamp","startTimestamp","timeseriesId","all","results","metrics","r","regexp","RegExp","m","processDatapoints","result","concat","test","serie","dimension","relativeTime","res","entities","pickBy","startsWith","key","map","d","i","text","value","getTsNames","query","entry","item","dataPoints","tsid","label","dp","x","identifiers","split","push","datapoints"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from 'lodash';\n\nexport default class DynatraceDatasource {\n  constructor(instanceSettings, $q, backendSrv, templateSrv) {\n    this.type = instanceSettings.type;\n    this.name = instanceSettings.name;\n    this.q = $q;\n\n    this.id = instanceSettings.jsonData.id;\n    this.token = instanceSettings.jsonData.token;\n\n    this.url = `${instanceSettings.url}/e/${this.id}/api/v1/timeseries`;\n\n    this.headers = { Authorization: `Api-Token ${this.token}` };\n\n    this.backendSrv = backendSrv;\n    this.templateSrv = templateSrv;\n  }\n\n  doRequest(options) {\n    options.url = this.url;\n    options.headers = this.headers;\n    return this.backendSrv.datasourceRequest(options);\n  }\n\n  testDatasource() {\n    return this.doRequest({}).then(() => ({\n      status: 'success', message: 'Data source is working', title: 'Success',\n    })).catch(() => ({\n      status: 'error', message: 'Datasource test failed', title: 'Error',\n    }));\n  }\n\n  query(options) {\n    const targets = _.filter(options.targets, (target => !target.hide));\n    const fromTs = options.range.from._d.getTime();\n    const toTs = options.range.to._d.getTime();\n    const requests = [];\n\n    Object.keys(targets).forEach((t) => {\n      const opts = {\n        method: 'POST',\n        data: {\n          aggregationType: targets[t].aggregation,\n          endTimestamp: toTs,\n          startTimestamp: fromTs,\n          timeseriesId: targets[t].target,\n        },\n      };\n      requests[t] = this.doRequest(opts);\n    });\n\n    // TODO: this throws an error when one of the requests fails\n    // Would be better to finish all requests which do work\n    return this.q.all(requests).then((results) => {\n      let metrics = [];\n\n      Object.keys(results).forEach((r) => {\n        const regexp = new RegExp(targets[r].filter);\n        const m = DynatraceDatasource.processDatapoints(results[r].data.result);\n\n        metrics = metrics.concat(_.filter(m, serie => regexp.test(serie.target)));\n      });\n\n      return { data: metrics };\n    }).catch(() => ({\n      data: [], // TODO: Handle properly\n    }));\n  }\n\n  static processDatapoints(result) {\n    const r = [];\n\n    Object.keys(result.dataPoints).forEach((tsid) => {\n      let label = '';\n      const dp = result.dataPoints[tsid].map(x => [x[1], x[0]]);\n      const identifiers = tsid.split(', ');\n\n      Object.keys(identifiers).forEach((id) => {\n        label += `${result.entities[identifiers[id]]} `;\n      });\n\n      r.push({\n        target: label,\n        datapoints: dp,\n      });\n    });\n\n    return r;\n  }\n\n  getEntities(target, dimension) {\n    const options = {\n      method: 'POST',\n      data: {\n        aggregationType: 'AVG',\n        relativeTime: 'hour',\n        timeseriesId: target,\n      },\n    };\n\n    return this.doRequest(options).then((res) => {\n      const entities = _.pickBy(res.data.result.entities, key =>\n        (_.startsWith(key, dimension)));\n\n      return _.map(entities, (d, i) => (\n        { text: d, value: i }\n      ));\n    });\n  }\n\n  metricFindQuery() {\n    // var interpolated = {\n    //     target: this.templateSrv.replace(query, null, 'regex')\n    // };\n\n    return this.doRequest({\n      method: 'GET',\n    }).then(DynatraceDatasource.getTsNames);\n  }\n\n  metricFindDetails(query) {\n    // TODO: Don't do a new request but take results from findquery\n    return this.doRequest({\n      method: 'GET',\n    }).then((res) => {\n      const entry = _.filter(res.data, item =>\n        (item.timeseriesId === query))[0];\n\n      return entry;\n    }).catch(() => (false));\n  }\n\n  static getTsNames(result) {\n    return _.map(result.data, d => (\n      { text: d.timeseriesId, value: d.timeseriesId }));\n  }\n}\n\n"]}